\chapter{Evaluation}

\section{Process}

The process adhered to in this application was an adaptation of Agile Development, with inspiration taken from Kanban and Extreme Programming. A number of studies had been written on adapting agile development to a single developer, which had been reviewed before laying out the principles of the development process in section~\ref{xp}.

Overall it was felt that taking an agile approach to the project was the correct means of development. A distinct benefit from a lack of a development team is a complete ownership of the product's code base, with no need to take time to understand what another developer has written. This allowed for swift changes to be made to support and enhance the original requirements of the project. One example is the logic in the exception handler for data integrity violations in points of interest. At a late stage of the project, it was decided that there was a clearer way to display an error message to a user than simply presenting the exception string - this could be confusing to a user who does not have an understanding of SQL constraints. A switch statement was added to handle the constraint that had been violated, which overall allowed for a better presentation of the application and less of a chance for a user to become confused when adding or editing points of interest. If a waterfall methodology was used, it would have been difficult to not clearly define this in the design. Time would have to be taken to modify the specification and update it in a version control system.

Other benefits of using agile development were the lack of a need for formal documentation. Creation of specifications and status reports would have most likely not be read by anybody other than the person authoring it, rendering them redundant. It would have also caused delays to the development stage - a Waterfall approach may have required the customer to approve a design and receive regular status reports which, again, would have been an unnecessary burden on the customer, who had already made their requirements clear in an in-person meeting. An agile approach allowed for this to be changed, and for an iterative approach to design and development that allowed for development builds to be regularly made.

However, a more orthodox approach to agile development may have been a good idea, to ensure that the advantages that an agile approach could bring are utilised to their fullest extent. While it was intended, there were many times when a motivation to use the Pomodoro technique as a solution to timeboxing was lacking, inevitably resulting in XP practices surrounding working conditions being ignored. On reflection, lower-quality code was found and had to be edited close to the submission date of the project, which could have been avoided if an emphasis was placed on focus.

Test-driven development was intended to be the driving force behind development, with research being made into the best way to utilise the various automated testing frameworks behind web development. While some minor research into solutions such as Selenium IDE, where you could record your actions and re-run the test each time a change was made, this was eventually not used and there was not as much of an emphasis placed on writing useful unit tests as there should have been. While manual test tables had been produced it is unfortunate that a full suite of tests could not be run on every build. Travis CI was also used, as discussed in chapter 1, however this was discontinued. As the application became more complex, it was difficult to understand how to utilise Travis CI to its fullest potential, for example, instantiating a PostgreSQL database. Errors in the application may have been found sooner if this was utilised properly.

\section{Technology}

The technology stack used in this application was primarily Java, with some front-end JavaScript also in use. Overall, it was felt that this was a sensible choice for production of a web application, after performing spike work on various other stacks.

A benefit of utilising a Java-based stack was a familiarity with Java, and the concepts of object-oriented programming. If a Python or JavaScript-based framework was used instead this would have had the potential for code to be far less efficient and more badly-written. A considerable length of time would have had to be put aside for learning the differences between Java and another stack. This is not to suggest, however, that there was not a learning curve to using Spring. Research into the best utilisation of a model-view-controller framework had to be carried out, with attention having to be placed on the differences between standard Java and Java Enterprise Edition. JavaScript also had to be utilised in the application, a language where there was an element of unfamiliarity.

Whilst, compared to many other Java EE applications, the Spring Framework can arguably be considered lightweight, other frameworks, such as Django, could perhaps have been faster, and there may have been both an educational benefit to becoming more proficient in a different programming language as well as a benefit to the speed of the application. Spring requires a very large number of dependencies, with it becoming very easy to have a bloated application. It would have perhaps been beneficial to take more time to evaluate the advantages and disadvantages of different frameworks, and draw a comparison between them.

Utilising Material Design as a front-end design language was overall a suitable choice. The design was minimalistic however, from an opinionated standpoint, were generally aesthetically pleasing and clear to understand. Some aspects of Materialize were difficult to implement, suggesting a lack of compatibility with many parts of Spring. There were, however, appropriate workarounds to this. It could have been beneficial if Material Design was chosen as the design language at the prototyping stage - the prototypes that were created used Semantic UI. Whilst there are many comparisons you can make between the two frameworks, time did have to be spent to find alternative approaches to design considerations that had been made at the planning and design stages.

\section{Engagement with Customer}

Engagement with the customer, the Montgomeryshire Wildlife Trust, was through a project management team that had been assigned the project of building a visitor centre for the Dyfi Osprey Project. Overall, there was a good amount of engagement and discussion between the developer and the customer, ensuring at least an attempted fulfilment of the Agile value of customer collaboration.

A note for improvement could have been more ready communication between the initial meeting in February, and the completion of a Minimum Viable Product in April. Unforeseen events restricted person-to-person communication in the latter half of the project, however this could have been replaced with more communication via e-mail and telephone. It will be envisaged that installation and execution of the web application may be complex, depending on the operating system being used to run the server. However, a commitment to providing ongoing ad-hoc support for the customer will ensure issues are resolved, and the software is not rendered unusable.
 
\section{Future Work}

There are various parts of the project which could benefit from future work, with the main points being:

\begin{itemize}
	\item \textbf{Completion of requirements} - It is unfortunate that not all the proposed requirements had been implemented, leaving some user stories unfulfilled. These include the lack of I18N internationalisation, with the suggested workaround being simply typing point of interest information in both English and Welsh, and the inclusion of image uploads. A future build of this project could potentially include these, as well as various other convenience features, such as the use of a directions API and the inclusion of public transport times.
	\item \textbf{Cloud Hosting} - It is unclear if hosting the application on a local computer will be sustainable in the long term, as the computer may need to be redeployed to a user, and there is a potential for it to fail. A lack of HTTPS is also a potential security concern. An evaluation of different cloud hosting providers could be carried out, with the application installed on a cloud instance and there being a possibility for it to be configured to be available on the World Wide Web.
	\item \textbf{Support for KML files} - KML files are files that include waypoint-style location data. It was mentioned by the customer that the migration patterns of the Ospreys are tracked with a GPS tag attached to their legs. This may be of interest to visitors, and could help with the customer being able to educate visitors on how and when Ospreys migrate.
	\item \textbf{Addition of user roles} - User roles could perhaps be introduced, as part of a more comprehensive content management system. For example, a manager could have administrator access, and be able to register and delete users as well as edit points of interest. A volunteer could have editor access, which only allows them to edit points of interest. This would allow for a more structured system, with a reduction of errors on the part of the application user.
\end{itemize}

\section{Summary}

Overall, many aspects of this project went well. A large array of skills from various areas in a Computer Science degree were utilised during this project, including ensuring a steady stream of individual research and learning, as some aspects of web development used in this project had not been explicitly taught. Feedback from the customer, after an example demonstration of a development build of the application, was positive, and they are looking forward to utilising the software when their building has been opened.

There were, however, parts of the project that could be improved. A closer adherence to the values of Test-Driven Development, and Extreme Programming, could have been beneficial. Arguably, some of the logic in the application was inefficient, and it may have been advantageous to take time to review the efficiency of each method and refactor where necessary. A suggestion to host the application on a cloud platform could have also been a better solution than a locally-hosted application, with no simple one-click method to installation. The report itself is very long, with a word count of approximate 15,500. While this is still within the maximum word count of 20,000, the recommended count was between 10,000 and 12,000. It may had been advantageous to ensure that all content in the report was useful for submission.

In conclusion, development of this software has been successful, and has been a good way to conclude a degree. The knowledge gained through this project will be beneficial in any further study and employment, with technologies used in this application particularly relevant.

%1713
%Report total: 15518